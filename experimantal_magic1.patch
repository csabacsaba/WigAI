Subject: [PATCH] experimantal magic
---
Index: src/main/java/io/github/fabb/wigai/common/validation/ParameterValidator.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/io/github/fabb/wigai/common/validation/ParameterValidator.java b/src/main/java/io/github/fabb/wigai/common/validation/ParameterValidator.java
--- a/src/main/java/io/github/fabb/wigai/common/validation/ParameterValidator.java	(revision 3257236b82bd84c916ebff2f184e8f162f39a6d2)
+++ b/src/main/java/io/github/fabb/wigai/common/validation/ParameterValidator.java	(date 1761597197782)
@@ -93,6 +93,31 @@
         return ((Number) value).intValue();
     }
 
+    /**
+     * Validates and extracts an optional integer parameter.
+     *
+     * @param arguments The arguments map
+     * @param parameterName The parameter name
+     * @param operation The operation context
+     * @return The integer value, or null if not present
+     * @throws BitwigApiException if the parameter is present but not a number
+     */
+    public static Integer validateOptionalInteger(Map<String, Object> arguments, String parameterName, String operation) {
+        Object value = arguments.get(parameterName);
+        if (value == null) {
+            return null;
+        }
+        if (!(value instanceof Number)) {
+            throw new BitwigApiException(
+                ErrorCode.INVALID_PARAMETER_TYPE,
+                operation,
+                parameterName + " must be an integer",
+                Map.of("parameter", parameterName, "value", value)
+            );
+        }
+        return ((Number) value).intValue();
+    }
+
     /**
      * Validates and extracts a required double parameter.
      *
Index: build.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build.gradle.kts b/build.gradle.kts
--- a/build.gradle.kts	(revision 3257236b82bd84c916ebff2f184e8f162f39a6d2)
+++ b/build.gradle.kts	(date 1761320969226)
@@ -41,11 +41,7 @@
     testRuntimeOnly("org.junit.jupiter:junit-jupiter-engine:5.10.0")
 }
 
-java {
-    // Configure Java 21 LTS
-    sourceCompatibility = JavaVersion.VERSION_21
-    targetCompatibility = JavaVersion.VERSION_21
-}
+
 
 // Configure testing using the Test Suites DSL (avoids deprecated auto-loading in Gradle 9)
 testing {
@@ -94,3 +90,25 @@
 tasks.named("build") {
     dependsOn("bwextension")
 }
+
+// Task to create the API Introspector .bwextension file
+tasks.register<Jar>("introspectorExtension") {
+    group = "build"
+    description = "Creates the API Introspector .bwextension file for debugging"
+
+    dependsOn(tasks.named<com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar>("shadowJar"))
+
+    archiveFileName.set("WigAI-Introspector.bwextension")
+    destinationDirectory.set(layout.buildDirectory.dir("extensions"))
+
+    manifest {
+        attributes(
+            "Implementation-Title" to "WigAI API Introspector",
+            "Implementation-Version" to project.version.toString(),
+            "Implementation-Vendor" to project.group.toString(),
+            "Created-By" to "Gradle ${gradle.gradleVersion}",
+        )
+    }
+
+    from(tasks.named<com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar>("shadowJar").map { zipTree(it.archiveFile) })
+}
Index: src/main/java/io/github/fabb/wigai/WigAIExtension.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/io/github/fabb/wigai/WigAIExtension.java b/src/main/java/io/github/fabb/wigai/WigAIExtension.java
--- a/src/main/java/io/github/fabb/wigai/WigAIExtension.java	(revision 3257236b82bd84c916ebff2f184e8f162f39a6d2)
+++ b/src/main/java/io/github/fabb/wigai/WigAIExtension.java	(date 1761371763656)
@@ -60,10 +60,130 @@
         // Start the Jetty server and MCP server
         startServer();
 
+        // Run API introspection
+        logger.info("DEBUG: About to run API introspection...");
+        host.println("DEBUG: About to run API introspection...");
+        try {
+            runApiIntrospection();
+            logger.info("DEBUG: API introspection completed successfully");
+            host.println("DEBUG: API introspection completed successfully");
+        } catch (Exception e) {
+            logger.error("DEBUG: API introspection FAILED", e);
+            host.println("DEBUG: API introspection FAILED with exception: " + e.getClass().getName() + " - " + e.getMessage());
+            e.printStackTrace();
+        }
+
         // Log startup message
         logger.info(String.format("WigAI Extension Loaded - Version %s", getExtensionDefinition().getVersion()));
     }
 
+    /**
+     * Run API introspection to examine available Bitwig API methods.
+     */
+    private void runApiIntrospection() {
+        final ControllerHost host = getHost();
+        
+        String separator = "================================================================================";
+        host.println(separator);
+        host.println("[API Introspector] Starting reflection test...");
+        host.println(separator);
+
+        try {
+            // 1) Project + first track
+            com.bitwig.extension.controller.api.Project project = host.getProject();
+            com.bitwig.extension.controller.api.TrackBank tb = host.createTrackBank(1, 0, 8);
+            com.bitwig.extension.controller.api.Track track = tb.getItemAt(0);
+            track.selectInMixer();
+
+            // 2) Basic API classes introspection
+            printApiMethods(host, "ControllerHost", host.getClass());
+            printApiMethods(host, "Project", project.getClass());
+            printApiMethods(host, "Track", track.getClass());
+
+            // 3) Device chain introspection
+            com.bitwig.extension.controller.api.DeviceBank db = track.createDeviceBank(8);
+            com.bitwig.extension.controller.api.Device device = db.getItemAt(0);
+            printApiMethods(host, "Device", device.getClass());
+
+            // 4) Check for InsertionPoint specifically
+            host.println("");
+            host.println(separator);
+            host.println("[API Introspector] SEARCHING FOR INSERTION POINT METHODS:");
+            host.println(separator);
+            
+            checkForInsertionPointMethods(host, track, "Track");
+            checkForInsertionPointMethods(host, device, "Device");
+            
+            // 5) Get an actual InsertionPoint and introspect it
+            try {
+                java.lang.reflect.Method endOfChainMethod = track.getClass().getMethod("endOfDeviceChainInsertionPoint");
+                Object insertionPoint = endOfChainMethod.invoke(track);
+                if (insertionPoint != null) {
+                    printApiMethods(host, "InsertionPoint", insertionPoint.getClass());
+                } else {
+                    host.println("InsertionPoint is null!");
+                }
+            } catch (Exception e) {
+                host.println("Could not get InsertionPoint: " + e.getMessage());
+            }
+            
+            // 6) Introspect Browser API for device scanning
+            try {
+                com.bitwig.extension.controller.api.PopupBrowser browser = host.createPopupBrowser();
+                if (browser != null) {
+                    printApiMethods(host, "PopupBrowser", browser.getClass());
+                    browser.cancel(); // IMPORTANT: Close the browser to allow future PopupBrowser creation
+                } else {
+                    host.println("PopupBrowser is null!");
+                }
+            } catch (Exception e) {
+                host.println("Could not get PopupBrowser: " + e.getMessage());
+            }
+
+        } catch (Exception e) {
+            host.println("[API Introspector] ERROR: " + e.getClass().getSimpleName() + " - " + e.getMessage());
+            e.printStackTrace();
+        }
+
+        host.println("");
+        host.println(separator);
+        host.println("[API Introspector] Done. Check Bitwig log (Help â†’ Show Log Files).");
+        host.println(separator);
+    }
+
+    private void printApiMethods(ControllerHost host, String label, Class<?> clazz) {
+        host.println("");
+        host.println("---- " + label + " (" + clazz.getName() + ") ----");
+        String list = java.util.Arrays.stream(clazz.getMethods())
+            .map(java.lang.reflect.Method::getName)
+            .distinct()
+            .sorted(java.util.Comparator.naturalOrder())
+            .collect(java.util.stream.Collectors.joining(", "));
+        host.println(list);
+    }
+
+    private void checkForInsertionPointMethods(ControllerHost host, Object obj, String label) {
+        host.println("");
+        host.println("Checking " + label + " for insertion point methods:");
+        
+        java.lang.reflect.Method[] methods = obj.getClass().getMethods();
+        boolean found = false;
+        
+        for (java.lang.reflect.Method method : methods) {
+            String name = method.getName().toLowerCase();
+            if (name.contains("insertion") || name.contains("insert") || name.contains("device")) {
+                host.println("  - " + method.getName() + " : " + 
+                             java.util.Arrays.toString(method.getParameterTypes()) + " -> " + 
+                             method.getReturnType().getSimpleName());
+                found = true;
+            }
+        }
+        
+        if (!found) {
+            host.println("  (no insertion-related methods found)");
+        }
+    }
+
     /**
      * Starts the Jetty server and registers all servlets.
      */
Index: src/main/java/io/github/fabb/wigai/bitwig/BitwigApiFacade.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/io/github/fabb/wigai/bitwig/BitwigApiFacade.java b/src/main/java/io/github/fabb/wigai/bitwig/BitwigApiFacade.java
--- a/src/main/java/io/github/fabb/wigai/bitwig/BitwigApiFacade.java	(revision 3257236b82bd84c916ebff2f184e8f162f39a6d2)
+++ b/src/main/java/io/github/fabb/wigai/bitwig/BitwigApiFacade.java	(date 1761597060808)
@@ -10,6 +10,7 @@
 import io.github.fabb.wigai.common.validation.ParameterValidator;
 
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
@@ -46,12 +47,20 @@
     private final Application application;
     private final Logger logger;
     private final CursorDevice cursorDevice;
-    private final RemoteControlsPage deviceParameterBank;
+    private final CursorRemoteControlsPage deviceParameterBank;
     private final TrackBank trackBank;
     private final SceneBankFacade sceneBankFacade;
     private final CursorTrack cursorTrack;
-    private final RemoteControlsPage projectParameterBank;
+    private final CursorRemoteControlsPage projectParameterBank;
     private final List<DeviceBank> trackDeviceBanks;
+    private NoteInput noteInput; // Nullable - only available if MIDI port exists
+    private final Clip cursorClip; // For writing notes to clips
+    // private final VstPluginScanner vstPluginScanner; // For scanning available plugins - TEMPORARILY DISABLED
+
+    // Cache for currently selected device and page to avoid unnecessary switches
+    private Integer currentlySelectedTrackIndex = null;
+    private Integer currentlySelectedDeviceIndex = null;
+    private Integer currentlySelectedPageIndex = null;
 
     /**
      * Creates a new BitwigApiFacade instance.
@@ -93,6 +102,11 @@
         this.trackBank = host.createTrackBank(Constants.MAX_TRACKS, 0, Constants.MAX_SCENES);
         this.sceneBankFacade = new SceneBankFacade(host, logger, Constants.MAX_SCENES); // Support up to 128 scenes for full functionality
 
+        // Initialize CursorClip for writing notes to clips
+        // Grid: 256 steps (16 bars * 16 steps), 128 pitches (full MIDI range)
+        this.cursorClip = host.createLauncherCursorClip(256, 128);
+        this.cursorClip.scrollToKey(0); // Start at C-1 (MIDI note 0)
+
         // Initialize device banks for each track to enable device enumeration
         this.trackDeviceBanks = new ArrayList<>();
         for (int i = 0; i < trackBank.getSizeOfBank(); i++) {
@@ -107,6 +121,11 @@
         cursorDevice.isEnabled().markInterested();
         cursorDevice.deviceType().markInterested();
 
+        // Mark interest in device parameter bank page navigation
+        deviceParameterBank.pageCount().markInterested();
+        deviceParameterBank.selectedPageIndex().markInterested();
+        deviceParameterBank.pageNames().markInterested();
+
         // Mark interest in all device parameter properties to enable value access
         for (int i = 0; i < deviceParameterBank.getParameterCount(); i++) {
             RemoteControl parameter = deviceParameterBank.getParameter(i);
@@ -202,6 +221,21 @@
                 slot.name().markInterested();
             }
         }
+
+        // Initialize MIDI note input for sending MIDI messages
+        // Only create if MIDI ports are available
+        try {
+            this.noteInput = host.getMidiInPort(0).createNoteInput("WigAI MIDI", "??????");
+            this.noteInput.setShouldConsumeEvents(false);
+            logger.info("BitwigApiFacade: MIDI input initialized successfully");
+        } catch (Exception e) {
+            logger.info("BitwigApiFacade: MIDI input not available: " + e.getMessage());
+            this.noteInput = null;
+        }
+
+        // Initialize VST Plugin Scanner - TEMPORARILY DISABLED
+        // this.vstPluginScanner = new VstPluginScanner(host, logger);
+        // logger.info("BitwigApiFacade: VST Plugin Scanner initialized");
     }
 
     // ========================================
@@ -432,9 +466,10 @@
             // Validate value range
             ParameterValidator.validateParameterValue(value, operation);
 
-            // Set the parameter value
+            // Set the parameter value using setImmediately (Moss-style approach)
+            // This bypasses take-over modes and sets the value directly
             RemoteControl parameter = deviceParameterBank.getParameter(parameterIndex);
-            parameter.value().set(value);
+            parameter.value().setImmediately(value);
 
             logger.info("BitwigApiFacade: Successfully set parameter " + parameterIndex + " to " + value);
         });
@@ -1750,4 +1785,1504 @@
         String selectedDeviceName = cursorDevice.name().get();
         return deviceName.equals(selectedDeviceName);
     }
+
+    // ========================================
+    // MIDI Operations
+    // ========================================
+
+    /**
+     * Sends a MIDI note on message.
+     *
+     * @param channel The MIDI channel (0-15)
+     * @param pitch The note pitch (0-127, where 60 is middle C)
+     * @param velocity The note velocity (0-127)
+     * @throws BitwigApiException if parameters are out of range
+     */
+    public void sendMidiNoteOn(int channel, int pitch, int velocity) throws BitwigApiException {
+        final String operation = "sendMidiNoteOn";
+        logger.info("BitwigApiFacade: Sending MIDI Note On - channel: " + channel + ", pitch: " + pitch + ", velocity: " + velocity);
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            // Check if MIDI input is available
+            if (noteInput == null) {
+                throw new BitwigApiException(
+                    ErrorCode.OPERATION_FAILED,
+                    operation,
+                    "MIDI functionality is not available. Please ensure a MIDI input port is configured in Bitwig."
+                );
+            }
+
+            // Validate channel (0-15)
+            if (channel < 0 || channel > 15) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "MIDI channel must be between 0 and 15, got: " + channel,
+                    Map.of("channel", channel)
+                );
+            }
+
+            // Validate pitch (0-127)
+            if (pitch < 0 || pitch > 127) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "MIDI pitch must be between 0 and 127, got: " + pitch,
+                    Map.of("pitch", pitch)
+                );
+            }
+
+            // Validate velocity (0-127)
+            if (velocity < 0 || velocity > 127) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "MIDI velocity must be between 0 and 127, got: " + velocity,
+                    Map.of("velocity", velocity)
+                );
+            }
+
+            // Send MIDI note on message
+            // Status byte: 0x90 (note on) + channel
+            int statusByte = 0x90 | (channel & 0x0F);
+            noteInput.sendRawMidiEvent(statusByte, pitch, velocity);
+
+            logger.info("BitwigApiFacade: Successfully sent MIDI Note On");
+        });
+    }
+
+    /**
+     * Sends a MIDI note off message.
+     *
+     * @param channel The MIDI channel (0-15)
+     * @param pitch The note pitch (0-127)
+     * @throws BitwigApiException if parameters are out of range
+     */
+    public void sendMidiNoteOff(int channel, int pitch) throws BitwigApiException {
+        final String operation = "sendMidiNoteOff";
+        logger.info("BitwigApiFacade: Sending MIDI Note Off - channel: " + channel + ", pitch: " + pitch);
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            // Check if MIDI input is available
+            if (noteInput == null) {
+                throw new BitwigApiException(
+                    ErrorCode.OPERATION_FAILED,
+                    operation,
+                    "MIDI functionality is not available. Please ensure a MIDI input port is configured in Bitwig."
+                );
+            }
+
+            // Validate channel (0-15)
+            if (channel < 0 || channel > 15) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "MIDI channel must be between 0 and 15, got: " + channel,
+                    Map.of("channel", channel)
+                );
+            }
+
+            // Validate pitch (0-127)
+            if (pitch < 0 || pitch > 127) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "MIDI pitch must be between 0 and 127, got: " + pitch,
+                    Map.of("pitch", pitch)
+                );
+            }
+
+            // Send MIDI note off message
+            // Status byte: 0x80 (note off) + channel
+            int statusByte = 0x80 | (channel & 0x0F);
+            noteInput.sendRawMidiEvent(statusByte, pitch, 0);
+
+            logger.info("BitwigApiFacade: Successfully sent MIDI Note Off");
+        });
+    }
+
+    /**
+     * Sends a MIDI Control Change message.
+     *
+     * @param channel The MIDI channel (0-15)
+     * @param controller The controller number (0-127)
+     * @param value The controller value (0-127)
+     * @throws BitwigApiException if parameters are out of range
+     */
+    public void sendMidiCC(int channel, int controller, int value) throws BitwigApiException {
+        final String operation = "sendMidiCC";
+        logger.info("BitwigApiFacade: Sending MIDI CC - channel: " + channel + ", controller: " + controller + ", value: " + value);
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            // Check if MIDI input is available
+            if (noteInput == null) {
+                throw new BitwigApiException(
+                    ErrorCode.OPERATION_FAILED,
+                    operation,
+                    "MIDI functionality is not available. Please ensure a MIDI input port is configured in Bitwig."
+                );
+            }
+
+            // Validate channel (0-15)
+            if (channel < 0 || channel > 15) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "MIDI channel must be between 0 and 15, got: " + channel,
+                    Map.of("channel", channel)
+                );
+            }
+
+            // Validate controller (0-127)
+            if (controller < 0 || controller > 127) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "MIDI controller must be between 0 and 127, got: " + controller,
+                    Map.of("controller", controller)
+                );
+            }
+
+            // Validate value (0-127)
+            if (value < 0 || value > 127) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "MIDI CC value must be between 0 and 127, got: " + value,
+                    Map.of("value", value)
+                );
+            }
+
+            // Send MIDI CC message
+            // Status byte: 0xB0 (control change) + channel
+            int statusByte = 0xB0 | (channel & 0x0F);
+            noteInput.sendRawMidiEvent(statusByte, controller, value);
+
+            logger.info("BitwigApiFacade: Successfully sent MIDI CC");
+        });
+    }
+
+    // ========================================
+    // Clip Operations
+    // ========================================
+
+    /**
+     * Creates an empty clip in the specified track and clip slot.
+     *
+     * @param trackIndex The track index (0-based)
+     * @param slotIndex The clip slot index (0-based)
+     * @param lengthInBars The length of the clip in bars
+     * @throws BitwigApiException if parameters are invalid or operation fails
+     */
+    public void createEmptyClip(int trackIndex, int slotIndex, int lengthInBars) throws BitwigApiException {
+        final String operation = "createEmptyClip";
+        logger.info("BitwigApiFacade: Creating empty clip - track: " + trackIndex + ", slot: " + slotIndex + ", length: " + lengthInBars + " bars");
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            // Validate track index
+            if (trackIndex < 0 || trackIndex >= trackBank.getSizeOfBank()) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Track index must be between 0 and " + (trackBank.getSizeOfBank() - 1) + ", got: " + trackIndex,
+                    Map.of("trackIndex", trackIndex)
+                );
+            }
+
+            // Validate slot index
+            if (slotIndex < 0 || slotIndex >= Constants.MAX_SCENES) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Slot index must be between 0 and " + (Constants.MAX_SCENES - 1) + ", got: " + slotIndex,
+                    Map.of("slotIndex", slotIndex)
+                );
+            }
+
+            // Validate length
+            if (lengthInBars < 1 || lengthInBars > 16) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Length must be between 1 and 16 bars, got: " + lengthInBars,
+                    Map.of("lengthInBars", lengthInBars)
+                );
+            }
+
+            Track track = trackBank.getItemAt(trackIndex);
+            if (!track.exists().get()) {
+                throw new BitwigApiException(
+                    ErrorCode.TRACK_NOT_FOUND,
+                    operation,
+                    "Track at index " + trackIndex + " does not exist"
+                );
+            }
+
+            ClipLauncherSlotBank slotBank = track.clipLauncherSlotBank();
+            ClipLauncherSlot slot = slotBank.getItemAt(slotIndex);
+
+            // Create empty clip - length in beats
+            int lengthInBeats = lengthInBars * 4; // 4 beats per bar
+            slot.createEmptyClip(lengthInBeats);
+            slot.select(); // Select the slot so cursorClip points to it
+
+            logger.info("BitwigApiFacade: Successfully created empty clip");
+        });
+    }
+
+    /**
+     * Writes multiple notes to the current cursor clip in a single batch operation.
+     *
+     * @param notes List of note data maps containing "p" (pitch), "s" (step), "v" (velocity), "d" (duration)
+     * @throws BitwigApiException if parameters are invalid
+     */
+    public void writeNotesToClip(List<Map<String, Object>> notes) throws BitwigApiException {
+        final String operation = "writeNotesToClip";
+        logger.info("BitwigApiFacade: Writing " + notes.size() + " notes to clip in batch");
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            int noteCount = 0;
+            for (Map<String, Object> note : notes) {
+                // Extract and validate parameters
+                Object pObj = note.get("p");
+                Object sObj = note.get("s");
+                Object vObj = note.get("v");
+                Object dObj = note.get("d");
+
+                if (pObj == null || sObj == null || vObj == null || dObj == null) {
+                    throw new BitwigApiException(
+                        ErrorCode.INVALID_PARAMETER,
+                        operation,
+                        "Each note must have p, s, v, and d fields"
+                    );
+                }
+
+                int pitch = ((Number) pObj).intValue();
+                int stepPosition = ((Number) sObj).intValue();
+                int velocity = ((Number) vObj).intValue();
+                double durationInSteps = ((Number) dObj).doubleValue();
+
+                // Validate ranges
+                if (stepPosition < 0 || stepPosition >= 256) {
+                    throw new BitwigApiException(
+                        ErrorCode.INVALID_RANGE,
+                        operation,
+                        "Step position must be between 0 and 255, got: " + stepPosition + " for note " + noteCount
+                    );
+                }
+
+                if (pitch < 0 || pitch > 127) {
+                    throw new BitwigApiException(
+                        ErrorCode.INVALID_RANGE,
+                        operation,
+                        "Pitch must be between 0 and 127, got: " + pitch + " for note " + noteCount
+                    );
+                }
+
+                if (velocity < 1 || velocity > 127) {
+                    throw new BitwigApiException(
+                        ErrorCode.INVALID_RANGE,
+                        operation,
+                        "Velocity must be between 1 and 127, got: " + velocity + " for note " + noteCount
+                    );
+                }
+
+                if (durationInSteps <= 0 || durationInSteps > 64) {
+                    throw new BitwigApiException(
+                        ErrorCode.INVALID_RANGE,
+                        operation,
+                        "Duration must be between 0 and 64 steps, got: " + durationInSteps + " for note " + noteCount
+                    );
+                }
+
+                // Write the note
+                double durationInBeats = durationInSteps / 4.0;
+                cursorClip.setStep(stepPosition, pitch, velocity, durationInBeats);
+                noteCount++;
+            }
+
+            logger.info("BitwigApiFacade: Successfully wrote " + noteCount + " notes to clip");
+        });
+    }
+
+    /**
+     * Writes a single note to the current cursor clip.
+     *
+     * @param stepPosition Step position in 16th notes (0-based)
+     * @param pitch MIDI pitch (0-127, where 60 is Middle C)
+     * @param velocity Note velocity (1-127)
+     * @param durationInSteps Duration in 16th note steps
+     * @throws BitwigApiException if parameters are invalid
+     */
+    public void writeNoteToClip(int stepPosition, int pitch, int velocity, double durationInSteps) throws BitwigApiException {
+        final String operation = "writeNoteToClip";
+        logger.info("BitwigApiFacade: Writing note - step: " + stepPosition + ", pitch: " + pitch + ", velocity: " + velocity + ", duration: " + durationInSteps + " steps (" + (durationInSteps/4.0) + " beats)");
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            // Validate step position
+            if (stepPosition < 0 || stepPosition >= 256) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Step position must be between 0 and 255, got: " + stepPosition,
+                    Map.of("stepPosition", stepPosition)
+                );
+            }
+
+            // Validate pitch
+            if (pitch < 0 || pitch > 127) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Pitch must be between 0 and 127, got: " + pitch,
+                    Map.of("pitch", pitch)
+                );
+            }
+
+            // Validate velocity
+            if (velocity < 1 || velocity > 127) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Velocity must be between 1 and 127, got: " + velocity,
+                    Map.of("velocity", velocity)
+                );
+            }
+
+            // Validate duration
+            if (durationInSteps <= 0 || durationInSteps > 64) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Duration must be between 0 and 64 steps, got: " + durationInSteps,
+                    Map.of("durationInSteps", durationInSteps)
+                );
+            }
+
+            // Write the note using setStep
+            // Convert duration from 16th note steps to beats (4 steps = 1 beat)
+            double durationInBeats = durationInSteps / 4.0;
+            cursorClip.setStep(stepPosition, pitch, velocity, durationInBeats);
+
+            logger.info("BitwigApiFacade: Successfully wrote note to clip");
+        });
+    }
+
+    /**
+     * Clears all notes from the current cursor clip.
+     *
+     * @throws BitwigApiException if operation fails
+     */
+    public void clearClip() throws BitwigApiException {
+        final String operation = "clearClip";
+        logger.info("BitwigApiFacade: Clearing clip");
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            cursorClip.clearSteps();
+            logger.info("BitwigApiFacade: Successfully cleared clip");
+        });
+    }
+
+    /**
+     * Sets the loop length of the current cursor clip.
+     *
+     * @param lengthInBars Length in bars
+     * @throws BitwigApiException if parameters are invalid
+     */
+    public void setClipLoopLength(double lengthInBars) throws BitwigApiException {
+        final String operation = "setClipLoopLength";
+        logger.info("BitwigApiFacade: Setting clip loop length to " + lengthInBars + " bars");
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            if (lengthInBars <= 0 || lengthInBars > 16) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Length must be between 0 and 16 bars, got: " + lengthInBars,
+                    Map.of("lengthInBars", lengthInBars)
+                );
+            }
+
+            double lengthInBeats = lengthInBars * 4.0; // 4 beats per bar
+            cursorClip.getLoopLength().setRaw(lengthInBeats);
+            cursorClip.getPlayStop().setRaw(lengthInBeats);
+
+            logger.info("BitwigApiFacade: Successfully set clip loop length");
+        });
+    }
+
+    /**
+     * Selects a specific clip slot on a track in the clip launcher.
+     */
+    public void selectClipSlot(int trackIndex, int slotIndex) throws BitwigApiException {
+        final String operation = "selectClipSlot";
+        logger.info("BitwigApiFacade: Selecting clip slot - track: " + trackIndex + ", slot: " + slotIndex);
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            if (trackIndex < 0 || trackIndex >= trackBank.getSizeOfBank()) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Track index must be between 0 and " + (trackBank.getSizeOfBank() - 1) + ", got: " + trackIndex,
+                    Map.of("trackIndex", trackIndex)
+                );
+            }
+            if (slotIndex < 0 || slotIndex >= Constants.MAX_SCENES) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Slot index must be between 0 and " + (Constants.MAX_SCENES - 1) + ", got: " + slotIndex,
+                    Map.of("slotIndex", slotIndex)
+                );
+            }
+            Track track = trackBank.getItemAt(trackIndex);
+            if (!track.exists().get()) {
+                throw new BitwigApiException(
+                    ErrorCode.TRACK_NOT_FOUND,
+                    operation,
+                    "Track at index " + trackIndex + " does not exist"
+                );
+            }
+            ClipLauncherSlot slot = track.clipLauncherSlotBank().getItemAt(slotIndex);
+            slot.select();
+        });
+    }
+
+    /**
+     * Clears all notes from the clip at the given track and slot.
+     */
+    public void clearClipAt(int trackIndex, int slotIndex) throws BitwigApiException {
+        final String operation = "clearClipAt";
+        logger.info("BitwigApiFacade: Clearing clip at track: " + trackIndex + ", slot: " + slotIndex);
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            selectClipSlot(trackIndex, slotIndex);
+            clearClip();
+        });
+    }
+
+    /**
+     * Writes multiple notes to the clip at the given track and slot. Optionally replaces existing content.
+     * Notes must follow the compact schema used by writeNotes (p,s,d,v).
+     */
+    public void writeNotesAt(int trackIndex, int slotIndex, List<Map<String, Object>> notes, boolean replace) throws BitwigApiException {
+        final String operation = "writeNotesAt";
+        logger.info("BitwigApiFacade: Writing " + (notes != null ? notes.size() : 0) + " notes at track: " + trackIndex + ", slot: " + slotIndex + ", replace=" + replace);
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            if (notes == null || notes.isEmpty()) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_PARAMETER,
+                    operation,
+                    "Notes array must not be empty"
+                );
+            }
+            selectClipSlot(trackIndex, slotIndex);
+            if (replace) {
+                cursorClip.clearSteps();
+            }
+            writeNotesToClip(notes);
+        });
+    }
+
+    /**
+     * Checks if a clip exists at the given track and slot.
+     */
+    public boolean hasClipAt(int trackIndex, int slotIndex) throws BitwigApiException {
+        final String operation = "hasClipAt";
+        return WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            if (trackIndex < 0 || trackIndex >= trackBank.getSizeOfBank()) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Track index must be between 0 and " + (trackBank.getSizeOfBank() - 1) + ", got: " + trackIndex,
+                    Map.of("trackIndex", trackIndex)
+                );
+            }
+            if (slotIndex < 0 || slotIndex >= Constants.MAX_SCENES) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Slot index must be between 0 and " + (Constants.MAX_SCENES - 1) + ", got: " + slotIndex,
+                    Map.of("slotIndex", slotIndex)
+                );
+            }
+            Track track = trackBank.getItemAt(trackIndex);
+            if (!track.exists().get()) {
+                return false;
+            }
+            ClipLauncherSlotBank slotBank = track.clipLauncherSlotBank();
+            ClipLauncherSlot slot = slotBank.getItemAt(slotIndex);
+            return slot.hasContent().get();
+        });
+    }
+
+    /**
+     * Sets the name of the clip at the given track and slot.
+     */
+    public void setClipNameAt(int trackIndex, int slotIndex, String name) throws BitwigApiException {
+        final String operation = "setClipNameAt";
+        logger.info("BitwigApiFacade: Requested to set clip name at track: " + trackIndex + ", slot: " + slotIndex + " to '" + name + "'");
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            // Bitwig's public controller API does not support setting clip names directly via ClipLauncherSlot.name().
+            // We expose a clear error to the caller so higher layers can report unsupported_property.
+            throw new BitwigApiException(
+                ErrorCode.OPERATION_FAILED,
+                operation,
+                "Setting clip name is not supported by the current Bitwig Controller API"
+            );
+        });
+    }
+
+    /**
+     * Gets the name of the clip at the given track and slot, or null if empty.
+     */
+    public String getClipNameAt(int trackIndex, int slotIndex) throws BitwigApiException {
+        final String operation = "getClipNameAt";
+        return WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            Track track = trackBank.getItemAt(trackIndex);
+            if (!track.exists().get()) {
+                throw new BitwigApiException(
+                    ErrorCode.TRACK_NOT_FOUND,
+                    operation,
+                    "Track at index " + trackIndex + " does not exist"
+                );
+            }
+            ClipLauncherSlot slot = track.clipLauncherSlotBank().getItemAt(slotIndex);
+            if (!slot.hasContent().get()) {
+                return null;
+            }
+            String nm = slot.name().get();
+            return (nm != null && nm.trim().isEmpty()) ? null : nm;
+        });
+    }
+
+    /**
+     * Sets the loop length in beats for the clip at the given track and slot.
+     */
+    public void setClipLoopLengthBeatsAt(int trackIndex, int slotIndex, double lengthBeats) throws BitwigApiException {
+        final String operation = "setClipLoopLengthBeatsAt";
+        logger.info("BitwigApiFacade: Setting clip loop length (beats) at track: " + trackIndex + ", slot: " + slotIndex + " to " + lengthBeats + " beats");
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            if (lengthBeats <= 0 || lengthBeats > 64) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Length (beats) must be between 0 and 64, got: " + lengthBeats,
+                    Map.of("lengthBeats", lengthBeats)
+                );
+            }
+            selectClipSlot(trackIndex, slotIndex);
+            double bars = lengthBeats / 4.0;
+            setClipLoopLength(bars);
+        });
+    }
+
+    /**
+     * Reads back the loop length (in beats) for the clip at the given track and slot.
+     */
+    public double getClipLoopLengthBeatsAt(int trackIndex, int slotIndex) throws BitwigApiException {
+        final String operation = "getClipLoopLengthBeatsAt";
+        return WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            selectClipSlot(trackIndex, slotIndex);
+            double beats = cursorClip.getLoopLength().get();
+            return beats;
+        });
+    }
+
+    /**
+     * Inserts a Bitwig device using UUID-based matcher with reflection for API compatibility.
+     * This method inserts the device at the specified position by using beforeDeviceInsertionPoint()
+     * on the device currently at that position, or startOfDeviceChainInsertionPoint() for position 0.
+     *
+     * IMPORTANT: device_position parameter now works correctly. You can insert devices in normal order
+     * (0, 1, 2, 3) and they will appear at the correct positions in the device chain.
+     *
+     * Example batch operation to insert 4 devices in sequence on tracks 0-19:
+     * <pre>
+     * {
+     *   "name": "batch_operations",
+     *   "arguments": {
+     *     "operations": [
+     *       {
+     *         "type": "insert_device_on_tracks",
+     *         "args": {
+     *           "device_uuid": "e4815188-ba6f-4d14-bcfc-2dcb8f778ccb",
+     *           "device_position": 0,
+     *           "start_index": 0,
+     *           "end_index": 19
+     *         }
+     *       },
+     *       {
+     *         "type": "insert_device_on_tracks",
+     *         "args": {
+     *           "device_uuid": "6d621c1c-ab64-43b4-aea3-dad37e6f649c",
+     *           "device_position": 1,
+     *           "start_index": 0,
+     *           "end_index": 19
+     *         }
+     *       },
+     *       {
+     *         "type": "insert_device_on_tracks",
+     *         "args": {
+     *           "device_uuid": "2b1b4787-8d74-4138-877b-9197209eef0f",
+     *           "device_position": 2,
+     *           "start_index": 0,
+     *           "end_index": 19
+     *         }
+     *       },
+     *       {
+     *         "type": "insert_device_on_tracks",
+     *         "args": {
+     *           "device_uuid": "d275f9a6-0e4a-409c-9dc4-d74af90bc7ae",
+     *           "device_position": 3,
+     *           "start_index": 0,
+     *           "end_index": 19
+     *         }
+     *       }
+     *     ]
+     *   }
+     * }
+     * </pre>
+     *
+     * This will insert:
+     * - Position 0: EQ+ (UUID: e4815188-ba6f-4d14-bcfc-2dcb8f778ccb)
+     * - Position 1: Filter+ (UUID: 6d621c1c-ab64-43b4-aea3-dad37e6f649c)
+     * - Position 2: Compressor+ (UUID: 2b1b4787-8d74-4138-877b-9197209eef0f)
+     * - Position 3: Chorus+ (UUID: d275f9a6-0e4a-409c-9dc4-d74af90bc7ae)
+     *
+     * Technical implementation:
+     * - Position 0: Uses startOfDeviceChainInsertionPoint() to insert at the beginning
+     * - Position N (N>0): Uses afterDeviceInsertionPoint() on the device at position N-1
+     * - If position N-1 is empty: Uses endOfDeviceChainInsertionPoint() to insert at the end
+     *
+     * @param trackIndex Track index (0-based)
+     * @param devicePosition Position in device chain (0 = first position)
+     * @param deviceUuidStr UUID string of the Bitwig device
+     * @return true if device was inserted successfully, false otherwise
+     * @throws BitwigApiException if parameters are invalid
+     */
+    public boolean insertBitwigDeviceByUuid(int trackIndex, int devicePosition, String deviceUuidStr) throws BitwigApiException {
+        final String operation = "insertBitwigDeviceByUuid";
+        logger.info("BitwigApiFacade: Inserting Bitwig device - track: " + trackIndex +
+                    ", position: " + devicePosition + ", UUID: " + deviceUuidStr);
+
+        return WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            if (trackIndex < 0 || trackIndex >= trackBank.getSizeOfBank()) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Track index must be between 0 and " + (trackBank.getSizeOfBank() - 1) + ", got: " + trackIndex,
+                    Map.of("trackIndex", trackIndex)
+                );
+            }
+
+            if (devicePosition < 0) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Device position must be >= 0, got: " + devicePosition,
+                    Map.of("devicePosition", devicePosition)
+                );
+            }
+
+            Track track = trackBank.getItemAt(trackIndex);
+
+            if (!track.exists().get()) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_PARAMETER,
+                    operation,
+                    "Track does not exist at index: " + trackIndex,
+                    Map.of("trackIndex", trackIndex)
+                );
+            }
+
+            try {
+                // Parse UUID
+                java.util.UUID uuid = java.util.UUID.fromString(deviceUuidStr);
+
+                // Get insertion point based on desired position
+                Object insertionPoint = null;
+
+                if (devicePosition == 0) {
+                    // Insert at start of device chain
+                    try {
+                        java.lang.reflect.Method startOfChainMethod = track.getClass().getMethod("startOfDeviceChainInsertionPoint");
+                        insertionPoint = startOfChainMethod.invoke(track);
+                        logger.info("BitwigApiFacade: Using startOfDeviceChainInsertionPoint for position 0");
+                    } catch (NoSuchMethodException e) {
+                        logger.warn("BitwigApiFacade: startOfDeviceChainInsertionPoint not available, using endOfDeviceChainInsertionPoint");
+                        java.lang.reflect.Method endOfChainMethod = track.getClass().getMethod("endOfDeviceChainInsertionPoint");
+                        insertionPoint = endOfChainMethod.invoke(track);
+                    }
+                } else {
+                    // Insert after the device at position (devicePosition - 1)
+                    // This ensures we build the chain sequentially: 0, then after 0, then after 1, etc.
+                    DeviceBank deviceBank = trackDeviceBanks.get(trackIndex);
+                    Device previousDevice = deviceBank.getItemAt(devicePosition - 1);
+
+                    if (previousDevice.exists().get()) {
+                        // Use afterDeviceInsertionPoint to insert after the previous device
+                        java.lang.reflect.Method afterDeviceMethod = previousDevice.getClass().getMethod("afterDeviceInsertionPoint");
+                        insertionPoint = afterDeviceMethod.invoke(previousDevice);
+                        logger.info("BitwigApiFacade: Using afterDeviceInsertionPoint from device at position " + (devicePosition - 1));
+                    } else {
+                        // If the previous position doesn't have a device, insert at the end
+                        java.lang.reflect.Method endOfChainMethod = track.getClass().getMethod("endOfDeviceChainInsertionPoint");
+                        insertionPoint = endOfChainMethod.invoke(track);
+                        logger.info("BitwigApiFacade: Position " + (devicePosition - 1) + " empty, using endOfDeviceChainInsertionPoint");
+                    }
+                }
+
+                if (insertionPoint == null) {
+                    logger.info("BitwigApiFacade: Could not get insertion point");
+                    return false;
+                }
+
+                // Call insertBitwigDevice with UUID
+                java.lang.reflect.Method insertBitwigDevice = insertionPoint.getClass().getMethod("insertBitwigDevice", java.util.UUID.class);
+                insertBitwigDevice.invoke(insertionPoint, uuid);
+
+                logger.info("BitwigApiFacade: Successfully inserted Bitwig device via UUID at position " + devicePosition);
+                return true;
+
+            } catch (java.lang.IllegalArgumentException e) {
+                logger.info("BitwigApiFacade: Invalid UUID format: " + deviceUuidStr);
+                return false;
+            } catch (Exception e) {
+                logger.info("BitwigApiFacade: Device insertion failed: " + e.getClass().getSimpleName() +
+                           " - " + (e.getMessage() != null ? e.getMessage() : ""));
+                e.printStackTrace();
+                return false;
+            }
+        });
+    }
+
+    /**
+     * Gets the VST Plugin Scanner instance.
+     *
+     * @return The VST Plugin Scanner
+     */
+    public Object getVstPluginScanner() {
+        // return vstPluginScanner; // TEMPORARILY DISABLED
+        throw new UnsupportedOperationException("VstPluginScanner temporarily disabled");
+    }
+
+    // ========================================
+    // Track Creation/Deletion Operations
+    // ========================================
+
+    /**
+     * Creates a new instrument track at the end of the track list.
+     *
+     * @throws BitwigApiException if operation fails
+     */
+    public void createInstrumentTrack() throws BitwigApiException {
+        final String operation = "createInstrumentTrack";
+        logger.info("BitwigApiFacade: Creating instrument track");
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            application.createInstrumentTrack(-1);
+            logger.info("BitwigApiFacade: Successfully created instrument track");
+        });
+    }
+
+    /**
+     * Creates a new audio track at the end of the track list.
+     *
+     * @throws BitwigApiException if operation fails
+     */
+    public void createAudioTrack() throws BitwigApiException {
+        final String operation = "createAudioTrack";
+        logger.info("BitwigApiFacade: Creating audio track");
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            application.createAudioTrack(-1);
+            logger.info("BitwigApiFacade: Successfully created audio track");
+        });
+    }
+
+    /**
+     * Creates a new effect track at the end of the track list.
+     *
+     * @throws BitwigApiException if operation fails
+     */
+    public void createEffectTrack() throws BitwigApiException {
+        final String operation = "createEffectTrack";
+        logger.info("BitwigApiFacade: Creating effect track");
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            application.createEffectTrack(-1);
+            logger.info("BitwigApiFacade: Successfully created effect track");
+        });
+    }
+
+    /**
+     * Deletes the currently selected track.
+     *
+     * @throws BitwigApiException if no track is selected or operation fails
+     */
+    public void deleteSelectedTrack() throws BitwigApiException {
+        final String operation = "deleteSelectedTrack";
+        logger.info("BitwigApiFacade: Deleting selected track");
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            if (!cursorTrack.exists().get()) {
+                throw new BitwigApiException(
+                    ErrorCode.TRACK_NOT_FOUND,
+                    operation,
+                    "No track is currently selected"
+                );
+            }
+            
+            cursorTrack.deleteObject();
+            logger.info("BitwigApiFacade: Successfully deleted selected track");
+        });
+    }
+
+    /**
+     * Deletes a track by index.
+     *
+     * @param trackIndex The index of the track to delete (0-based)
+     * @throws BitwigApiException if track index is invalid or operation fails
+     */
+    public void deleteTrack(int trackIndex) throws BitwigApiException {
+        final String operation = "deleteTrack";
+        logger.info("BitwigApiFacade: Deleting track at index " + trackIndex);
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            if (trackIndex < 0 || trackIndex >= trackBank.getSizeOfBank()) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Track index must be between 0 and " + (trackBank.getSizeOfBank() - 1) + ", got: " + trackIndex,
+                    Map.of("trackIndex", trackIndex)
+                );
+            }
+
+            Track track = trackBank.getItemAt(trackIndex);
+            if (!track.exists().get()) {
+                throw new BitwigApiException(
+                    ErrorCode.TRACK_NOT_FOUND,
+                    operation,
+                    "Track at index " + trackIndex + " does not exist"
+                );
+            }
+
+            track.deleteObject();
+            logger.info("BitwigApiFacade: Successfully deleted track at index " + trackIndex);
+        });
+    }
+
+    // ========================================
+    // Track Properties Operations
+    // ========================================
+
+    /**
+     * Sets track properties (mute, solo, arm, volume, pan).
+     *
+     * @param trackIndex The index of the track (0-based)
+     * @param mute Optional mute state
+     * @param solo Optional solo state
+     * @param arm Optional arm state
+     * @param volume Optional volume (0.0-1.0)
+     * @param pan Optional pan (0.0-1.0, 0.5 is center)
+     * @throws BitwigApiException if track index is invalid or operation fails
+     */
+    public void setTrackProperties(int trackIndex, Boolean mute, Boolean solo, Boolean arm, 
+                                   Double volume, Double pan) throws BitwigApiException {
+        final String operation = "setTrackProperties";
+        logger.info("BitwigApiFacade: Setting track properties for track " + trackIndex);
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            if (trackIndex < 0 || trackIndex >= trackBank.getSizeOfBank()) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Track index must be between 0 and " + (trackBank.getSizeOfBank() - 1) + ", got: " + trackIndex,
+                    Map.of("trackIndex", trackIndex)
+                );
+            }
+
+            Track track = trackBank.getItemAt(trackIndex);
+            if (!track.exists().get()) {
+                throw new BitwigApiException(
+                    ErrorCode.TRACK_NOT_FOUND,
+                    operation,
+                    "Track at index " + trackIndex + " does not exist"
+                );
+            }
+
+            if (mute != null) {
+                track.mute().set(mute);
+                logger.info("BitwigApiFacade: Set mute to " + mute);
+            }
+
+            if (solo != null) {
+                track.solo().set(solo);
+                logger.info("BitwigApiFacade: Set solo to " + solo);
+            }
+
+            if (arm != null) {
+                track.arm().set(arm);
+                logger.info("BitwigApiFacade: Set arm to " + arm);
+            }
+
+            if (volume != null) {
+                if (volume < 0.0 || volume > 1.0) {
+                    throw new BitwigApiException(
+                        ErrorCode.INVALID_RANGE,
+                        operation,
+                        "Volume must be between 0.0 and 1.0, got: " + volume
+                    );
+                }
+                track.volume().set(volume);
+                logger.info("BitwigApiFacade: Set volume to " + volume);
+            }
+
+            if (pan != null) {
+                if (pan < 0.0 || pan > 1.0) {
+                    throw new BitwigApiException(
+                        ErrorCode.INVALID_RANGE,
+                        operation,
+                        "Pan must be between 0.0 and 1.0, got: " + pan
+                    );
+                }
+                track.pan().set(pan);
+                logger.info("BitwigApiFacade: Set pan to " + pan);
+            }
+
+            logger.info("BitwigApiFacade: Successfully set track properties");
+        });
+    }
+
+    /**
+     * Sets send properties for a specific track and send index.
+     *
+     * @param trackIndex The index of the track (0-based)
+     * @param sendIndex The index of the send (0-based)
+     * @param volume Optional send volume (0.0-1.0)
+     * @param enabled Optional send enabled state
+     * @throws BitwigApiException if indices are invalid or operation fails
+     */
+    public void setTrackSend(int trackIndex, int sendIndex, Double volume, Boolean enabled) throws BitwigApiException {
+        final String operation = "setTrackSend";
+        logger.info("BitwigApiFacade: Setting send " + sendIndex + " for track " + trackIndex);
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            if (trackIndex < 0 || trackIndex >= trackBank.getSizeOfBank()) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Track index must be between 0 and " + (trackBank.getSizeOfBank() - 1) + ", got: " + trackIndex,
+                    Map.of("trackIndex", trackIndex)
+                );
+            }
+
+            Track track = trackBank.getItemAt(trackIndex);
+            if (!track.exists().get()) {
+                throw new BitwigApiException(
+                    ErrorCode.TRACK_NOT_FOUND,
+                    operation,
+                    "Track at index " + trackIndex + " does not exist"
+                );
+            }
+
+            SendBank sendBank = track.sendBank();
+            int sendCount = sendBank.getSizeOfBank();
+
+            if (sendIndex < 0 || sendIndex >= sendCount) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Send index must be between 0 and " + (sendCount - 1) + ", got: " + sendIndex,
+                    Map.of("trackIndex", trackIndex, "sendIndex", sendIndex, "sendCount", sendCount)
+                );
+            }
+
+            Send send = sendBank.getItemAt(sendIndex);
+
+            if (volume != null) {
+                if (volume < 0.0 || volume > 1.0) {
+                    throw new BitwigApiException(
+                        ErrorCode.INVALID_RANGE,
+                        operation,
+                        "Send volume must be between 0.0 and 1.0, got: " + volume
+                    );
+                }
+                send.value().set(volume);
+                logger.info("BitwigApiFacade: Set send volume to " + volume);
+            }
+
+            if (enabled != null) {
+                send.isEnabled().set(enabled);
+                logger.info("BitwigApiFacade: Set send enabled to " + enabled);
+            }
+
+            logger.info("BitwigApiFacade: Successfully set send properties");
+        });
+    }
+
+    // ========================================
+    // Remote Controls Page Navigation
+    // ========================================
+
+    /**
+     * Switches the remote controls page for the currently selected device.
+     * Device pages contain different parameter mappings (e.g., "Gains", "Freqs", "Qs" for EQ+).
+     *
+     * @param pageIndex The zero-based page index to switch to
+     * @throws BitwigApiException if no device is selected or page index is invalid
+     */
+    public void switchDeviceRemoteControlsPage(int pageIndex) throws BitwigApiException {
+        final String operation = "switchDeviceRemoteControlsPage";
+        logger.info("BitwigApiFacade: Switching device remote controls page to index: " + pageIndex);
+
+        WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            // Check if device is selected
+            if (!cursorDevice.exists().get()) {
+                throw new BitwigApiException(ErrorCode.DEVICE_NOT_SELECTED, operation,
+                    "No device is currently selected");
+            }
+
+            // Validate page index
+            if (pageIndex < 0) {
+                throw new BitwigApiException(ErrorCode.INVALID_RANGE, operation,
+                    "Page index must be non-negative, got: " + pageIndex);
+            }
+
+            // Switch to the specified page
+            deviceParameterBank.selectedPageIndex().set(pageIndex);
+            
+            logger.info("BitwigApiFacade: Successfully switched to page " + pageIndex);
+        });
+    }
+
+    /**
+     * Gets the current remote controls page index for the selected device.
+     *
+     * @return The current page index
+     * @throws BitwigApiException if no device is selected
+     */
+    public int getCurrentDeviceRemoteControlsPageIndex() throws BitwigApiException {
+        final String operation = "getCurrentDeviceRemoteControlsPageIndex";
+        
+        return WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            // Check if device is selected
+            if (!cursorDevice.exists().get()) {
+                throw new BitwigApiException(ErrorCode.DEVICE_NOT_SELECTED, operation,
+                    "No device is currently selected");
+            }
+
+            return deviceParameterBank.selectedPageIndex().get();
+        });
+    }
+
+    /**
+     * Gets the total number of remote controls pages for the selected device.
+     *
+     * @return The total page count
+     * @throws BitwigApiException if no device is selected
+     */
+    public int getDeviceRemoteControlsPageCount() throws BitwigApiException {
+        final String operation = "getDeviceRemoteControlsPageCount";
+
+        return WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            // Check if device is selected
+            if (!cursorDevice.exists().get()) {
+                throw new BitwigApiException(ErrorCode.DEVICE_NOT_SELECTED, operation,
+                    "No device is currently selected");
+            }
+
+            return deviceParameterBank.pageCount().get();
+        });
+    }
+
+    /**
+     * Sets a device parameter value on a specific track.
+     * Uses reflection to access device's CursorRemoteControlsPage and parameter.
+     *
+     * @param trackIndex The track index (0-based)
+     * @param deviceIndex The device index on the track (0-based)
+     * @param parameterIndex The parameter index on the current page (0-based, typically 0-7)
+     * @param value The normalized value (0.0 to 1.0)
+     * @return true if parameter was set successfully, false otherwise
+     * @throws BitwigApiException if parameters are invalid
+     */
+    public boolean setDeviceParameterOnTrack(int trackIndex, int deviceIndex, int parameterIndex, double value) throws BitwigApiException {
+        final String operation = "setDeviceParameterOnTrack";
+        logger.info("BitwigApiFacade: Setting device parameter - track: " + trackIndex +
+                    ", device: " + deviceIndex + ", param: " + parameterIndex + ", value: " + value);
+
+        return WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            if (trackIndex < 0 || trackIndex >= trackBank.getSizeOfBank()) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Track index must be between 0 and " + (trackBank.getSizeOfBank() - 1) + ", got: " + trackIndex,
+                    Map.of("trackIndex", trackIndex)
+                );
+            }
+
+            if (deviceIndex < 0) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Device index must be >= 0, got: " + deviceIndex,
+                    Map.of("deviceIndex", deviceIndex)
+                );
+            }
+
+            if (parameterIndex < 0) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Parameter index must be >= 0, got: " + parameterIndex,
+                    Map.of("parameterIndex", parameterIndex)
+                );
+            }
+
+            if (value < 0.0 || value > 1.0) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Value must be between 0.0 and 1.0, got: " + value,
+                    Map.of("value", value)
+                );
+            }
+
+            try {
+                // Select the track first
+                Track track = trackBank.getItemAt(trackIndex);
+                track.selectInEditor();
+
+                // Get the device bank for this track and select the device
+                DeviceBank deviceBank = trackDeviceBanks.get(trackIndex);
+                Device device = deviceBank.getItemAt(deviceIndex);
+
+                if (!device.exists().get()) {
+                    logger.info("BitwigApiFacade: Device at index " + deviceIndex + " does not exist on track " + trackIndex);
+                    return false;
+                }
+
+                // Select the device - this makes cursorDevice point to this device
+                device.selectInEditor();
+
+                // Small delay to allow selection to take effect
+                Thread.sleep(50);
+
+                // Now use the already-initialized deviceParameterBank which follows cursorDevice
+                RemoteControl parameter = deviceParameterBank.getParameter(parameterIndex);
+                parameter.value().set(value);
+
+                logger.info("BitwigApiFacade: Successfully set parameter " + parameterIndex + " to " + value);
+                return true;
+
+            } catch (Exception e) {
+                logger.info("BitwigApiFacade: Failed to set parameter: " + e.getClass().getSimpleName() +
+                           " - " + (e.getMessage() != null ? e.getMessage() : ""));
+                e.printStackTrace();
+                return false;
+            }
+        });
+    }
+
+    /**
+     * Gets the displayed value of a device parameter (e.g., "107 Hz", "-6 dB").
+     * This allows the LLM to see what the normalized value actually means.
+     *
+     * @param trackIndex The track index (0-based)
+     * @param deviceIndex The device index on the track (0-based)
+     * @param parameterIndex The parameter index on the current page (0-based, typically 0-7)
+     * @return The displayed value string (e.g., "107 Hz"), or null if not available
+     * @throws BitwigApiException if parameters are invalid
+     */
+    public String getDeviceParameterDisplayedValue(int trackIndex, int deviceIndex, int parameterIndex) throws BitwigApiException {
+        final String operation = "getDeviceParameterDisplayedValue";
+
+        return WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            if (trackIndex < 0 || trackIndex >= trackBank.getSizeOfBank()) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Track index must be between 0 and " + (trackBank.getSizeOfBank() - 1) + ", got: " + trackIndex,
+                    Map.of("trackIndex", trackIndex)
+                );
+            }
+
+            try {
+                // Select the track and device (same as setDeviceParameterOnTrack)
+                Track track = trackBank.getItemAt(trackIndex);
+                track.selectInEditor();
+
+                DeviceBank deviceBank = trackDeviceBanks.get(trackIndex);
+                Device device = deviceBank.getItemAt(deviceIndex);
+
+                if (!device.exists().get()) {
+                    return null;
+                }
+
+                device.selectInEditor();
+                Thread.sleep(50);
+
+                // Get the displayed value from the parameter
+                RemoteControl parameter = deviceParameterBank.getParameter(parameterIndex);
+                String displayedValue = parameter.displayedValue().get();
+
+                return displayedValue;
+
+            } catch (Exception e) {
+                logger.info("BitwigApiFacade: Failed to get parameter displayed value: " + e.getClass().getSimpleName());
+                return null;
+            }
+        });
+    }
+
+    /**
+     * Gets the available remote control page names for a device at a specific position on a track.
+     *
+     * @param trackIndex  The index of the track (0-based)
+     * @param deviceIndex The index of the device on the track (0-based)
+     * @return List of page names, or empty list if device doesn't exist or no pages available
+     * @throws BitwigApiException if parameters are invalid
+     */
+    public List<String> getDevicePageNames(int trackIndex, int deviceIndex) throws BitwigApiException {
+        final String operation = "getDevicePageNames";
+        logger.info("BitwigApiFacade: Getting device page names - track: " + trackIndex + ", device: " + deviceIndex);
+
+        return WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            if (trackIndex < 0 || trackIndex >= trackBank.getSizeOfBank()) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Track index must be between 0 and " + (trackBank.getSizeOfBank() - 1) + ", got: " + trackIndex,
+                    Map.of("trackIndex", trackIndex)
+                );
+            }
+
+            if (deviceIndex < 0) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Device index must be >= 0, got: " + deviceIndex,
+                    Map.of("deviceIndex", deviceIndex)
+                );
+            }
+
+            try {
+                // Select the track if needed
+                if (currentlySelectedTrackIndex == null || !currentlySelectedTrackIndex.equals(trackIndex)) {
+                    Track track = trackBank.getItemAt(trackIndex);
+                    track.selectInEditor();
+                    Thread.sleep(50);
+                    currentlySelectedTrackIndex = trackIndex;
+                }
+
+                // Get the device bank for this track and check if device exists
+                DeviceBank deviceBank = trackDeviceBanks.get(trackIndex);
+                Device device = deviceBank.getItemAt(deviceIndex);
+
+                if (!device.exists().get()) {
+                    logger.info("BitwigApiFacade: Device at index " + deviceIndex + " does not exist on track " + trackIndex);
+                    return List.of();
+                }
+
+                // Select the device if needed - this makes cursorDevice point to this device
+                if (currentlySelectedDeviceIndex == null || !currentlySelectedDeviceIndex.equals(deviceIndex)) {
+                    device.selectInEditor();
+                    Thread.sleep(150);
+                    currentlySelectedDeviceIndex = deviceIndex;
+                    currentlySelectedPageIndex = null; // Reset page when switching device
+                }
+
+                // Now use the already-initialized deviceParameterBank which follows cursorDevice
+                String[] pageNamesArray = deviceParameterBank.pageNames().get();
+                List<String> pageNames = Arrays.asList(pageNamesArray);
+                logger.info("BitwigApiFacade: Found " + pageNames.size() + " pages: " + pageNames);
+                return pageNames;
+
+            } catch (Exception e) {
+                logger.info("BitwigApiFacade: Failed to get page names: " + e.getClass().getSimpleName() +
+                           " - " + (e.getMessage() != null ? e.getMessage() : ""));
+                e.printStackTrace();
+                return List.of();
+            }
+        });
+    }
+
+    /**
+     * Gets the parameter information for the current page of a device.
+     *
+     * @param trackIndex  The index of the track (0-based)
+     * @param deviceIndex The index of the device on the track (0-based)
+     * @return List of parameter info maps containing name, value, valueString
+     * @throws BitwigApiException if parameters are invalid
+     */
+    public List<Map<String, Object>> getDevicePageParameters(int trackIndex, int deviceIndex) throws BitwigApiException {
+        final String operation = "getDevicePageParameters";
+        logger.info("BitwigApiFacade: Getting device page parameters - track: " + trackIndex + ", device: " + deviceIndex);
+
+        return WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            if (trackIndex < 0 || trackIndex >= trackBank.getSizeOfBank()) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Track index must be between 0 and " + (trackBank.getSizeOfBank() - 1) + ", got: " + trackIndex,
+                    Map.of("trackIndex", trackIndex)
+                );
+            }
+
+            if (deviceIndex < 0) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Device index must be >= 0, got: " + deviceIndex,
+                    Map.of("deviceIndex", deviceIndex)
+                );
+            }
+
+            try {
+                // Select the track if needed
+                if (currentlySelectedTrackIndex == null || !currentlySelectedTrackIndex.equals(trackIndex)) {
+                    Track track = trackBank.getItemAt(trackIndex);
+                    track.selectInEditor();
+                    Thread.sleep(50);
+                    currentlySelectedTrackIndex = trackIndex;
+                }
+
+                // Get the device bank for this track and check if device exists
+                DeviceBank deviceBank = trackDeviceBanks.get(trackIndex);
+                Device device = deviceBank.getItemAt(deviceIndex);
+
+                if (!device.exists().get()) {
+                    logger.info("BitwigApiFacade: Device at index " + deviceIndex + " does not exist on track " + trackIndex);
+                    return List.of();
+                }
+
+                // Select the device if needed - this makes cursorDevice point to this device
+                if (currentlySelectedDeviceIndex == null || !currentlySelectedDeviceIndex.equals(deviceIndex)) {
+                    device.selectInEditor();
+                    Thread.sleep(150);
+                    currentlySelectedDeviceIndex = deviceIndex;
+                    currentlySelectedPageIndex = null; // Reset page when switching device
+                }
+
+                // Now use the already-initialized deviceParameterBank which follows cursorDevice
+                List<Map<String, Object>> parameters = new ArrayList<>();
+                for (int i = 0; i < deviceParameterBank.getParameterCount(); i++) {
+                    RemoteControl param = deviceParameterBank.getParameter(i);
+                    Map<String, Object> paramInfo = new LinkedHashMap<>();
+                    paramInfo.put("index", i);
+                    paramInfo.put("name", param.name().get());
+                    paramInfo.put("value", param.value().get());
+                    paramInfo.put("displayedValue", param.displayedValue().get());
+                    parameters.add(paramInfo);
+                }
+
+                logger.info("BitwigApiFacade: Found " + parameters.size() + " parameters on current page");
+                return parameters;
+
+            } catch (Exception e) {
+                logger.info("BitwigApiFacade: Failed to get page parameters: " + e.getClass().getSimpleName() +
+                           " - " + (e.getMessage() != null ? e.getMessage() : ""));
+                e.printStackTrace();
+                return List.of();
+            }
+        });
+    }
+
+    /**
+     * Switches the remote controls page for a specific device on a specific track.
+     * Uses reflection to access device's CursorRemoteControlsPage and set the page index.
+     *
+     * @param trackIndex The track index (0-based)
+     * @param deviceIndex The device index on the track (0-based)
+     * @param pageIndex The page index to switch to (0-based)
+     * @return true if page was switched successfully, false otherwise
+     * @throws BitwigApiException if parameters are invalid
+     */
+    public boolean switchDevicePageOnTrack(int trackIndex, int deviceIndex, int pageIndex) throws BitwigApiException {
+        final String operation = "switchDevicePageOnTrack";
+        logger.info("BitwigApiFacade: Switching device page - track: " + trackIndex +
+                    ", device: " + deviceIndex + ", page: " + pageIndex);
+
+        return WigAIErrorHandler.executeWithErrorHandling(operation, () -> {
+            if (trackIndex < 0 || trackIndex >= trackBank.getSizeOfBank()) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Track index must be between 0 and " + (trackBank.getSizeOfBank() - 1) + ", got: " + trackIndex,
+                    Map.of("trackIndex", trackIndex)
+                );
+            }
+
+            if (deviceIndex < 0) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Device index must be >= 0, got: " + deviceIndex,
+                    Map.of("deviceIndex", deviceIndex)
+                );
+            }
+
+            if (pageIndex < 0) {
+                throw new BitwigApiException(
+                    ErrorCode.INVALID_RANGE,
+                    operation,
+                    "Page index must be >= 0, got: " + pageIndex,
+                    Map.of("pageIndex", pageIndex)
+                );
+            }
+
+            try {
+                // Check if we're already on the requested device and page
+                if (currentlySelectedTrackIndex != null && currentlySelectedTrackIndex.equals(trackIndex) &&
+                    currentlySelectedDeviceIndex != null && currentlySelectedDeviceIndex.equals(deviceIndex) &&
+                    currentlySelectedPageIndex != null && currentlySelectedPageIndex.equals(pageIndex)) {
+                    logger.info("BitwigApiFacade: Already on track " + trackIndex + ", device " + deviceIndex + ", page " + pageIndex + " - skipping switch");
+                    return true;
+                }
+
+                // Select the track if needed
+                if (currentlySelectedTrackIndex == null || !currentlySelectedTrackIndex.equals(trackIndex)) {
+                    Track track = trackBank.getItemAt(trackIndex);
+                    track.selectInEditor();
+                    Thread.sleep(50);
+                    currentlySelectedTrackIndex = trackIndex;
+                }
+
+                // Get the device bank for this track and check if device exists
+                DeviceBank deviceBank = trackDeviceBanks.get(trackIndex);
+                Device device = deviceBank.getItemAt(deviceIndex);
+
+                if (!device.exists().get()) {
+                    logger.info("BitwigApiFacade: Device at index " + deviceIndex + " does not exist on track " + trackIndex);
+                    currentlySelectedDeviceIndex = null;
+                    currentlySelectedPageIndex = null;
+                    return false;
+                }
+
+                // Select the device if needed - this makes cursorDevice point to this device
+                if (currentlySelectedDeviceIndex == null || !currentlySelectedDeviceIndex.equals(deviceIndex)) {
+                    device.selectInEditor();
+                    Thread.sleep(150);
+                    currentlySelectedDeviceIndex = deviceIndex;
+                    currentlySelectedPageIndex = null; // Reset page when switching device
+                }
+
+                // Switch page if needed
+                if (currentlySelectedPageIndex == null || !currentlySelectedPageIndex.equals(pageIndex)) {
+                    deviceParameterBank.selectedPageIndex().set(pageIndex);
+                    Thread.sleep(150);
+                    currentlySelectedPageIndex = pageIndex;
+                }
+
+                logger.info("BitwigApiFacade: Successfully switched to track " + trackIndex + ", device " + deviceIndex + ", page " + pageIndex);
+                return true;
+
+            } catch (Exception e) {
+                logger.info("BitwigApiFacade: Failed to switch device page: " + e.getClass().getSimpleName() +
+                           " - " + (e.getMessage() != null ? e.getMessage() : ""));
+                e.printStackTrace();
+                return false;
+            }
+        });
+    }
 }
Index: src/main/java/io/github/fabb/wigai/mcp/McpServerManager.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/io/github/fabb/wigai/mcp/McpServerManager.java b/src/main/java/io/github/fabb/wigai/mcp/McpServerManager.java
--- a/src/main/java/io/github/fabb/wigai/mcp/McpServerManager.java	(revision 3257236b82bd84c916ebff2f184e8f162f39a6d2)
+++ b/src/main/java/io/github/fabb/wigai/mcp/McpServerManager.java	(date 1761571356879)
@@ -23,6 +23,18 @@
 import io.github.fabb.wigai.mcp.tool.GetDeviceDetailsTool;
 import io.github.fabb.wigai.mcp.tool.ListScenesTool;
 import io.github.fabb.wigai.mcp.tool.GetClipsInSceneTool;
+import io.github.fabb.wigai.mcp.tool.MidiTool;
+import io.github.fabb.wigai.mcp.tool.ClipWriterTool;
+import io.github.fabb.wigai.mcp.tool.DeviceInsertTool;
+// import io.github.fabb.wigai.mcp.tool.VstScannerTool; // TEMPORARILY DISABLED
+import io.github.fabb.wigai.mcp.tool.SwitchDevicePageTool;
+import io.github.fabb.wigai.mcp.tool.ListBitwigDevicesTool;
+import io.github.fabb.wigai.mcp.tool.TrackManagementTool;
+import io.github.fabb.wigai.mcp.tool.TrackPropertiesTool;
+import io.github.fabb.wigai.mcp.tool.BatchOperationsTool;
+import io.github.fabb.wigai.mcp.tool.GetDevicePageNamesTool;
+import io.github.fabb.wigai.mcp.tool.GetDevicePageParametersTool;
+import io.github.fabb.wigai.mcp.tool.GetDeviceKnowledgeTool;
 import io.modelcontextprotocol.spec.McpSchema;
 import com.bitwig.extension.controller.api.ControllerHost;
 import io.github.fabb.wigai.mcp.tool.SceneByNameTool;
@@ -148,11 +160,30 @@
                 DeviceParamTool.setSelectedDeviceParameterSpecification(deviceController, structuredLogger),
                 DeviceParamTool.setMultipleDeviceParametersSpecification(deviceController, structuredLogger),
                 GetDeviceDetailsTool.getDeviceDetailsSpecification(deviceController, structuredLogger),
+                SwitchDevicePageTool.switchDevicePageSpecification(bitwigApiFacade, structuredLogger),
                 ListTracksTool.specification(bitwigApiFacade, structuredLogger),
                 ListDevicesOnTrackTool.specification(bitwigApiFacade, structuredLogger),
                 GetTrackDetailsTool.specification(bitwigApiFacade, structuredLogger),
                 ListScenesTool.specification(bitwigApiFacade, structuredLogger),
-                GetClipsInSceneTool.getClipsInSceneSpecification(clipSceneController, structuredLogger)
+                GetClipsInSceneTool.getClipsInSceneSpecification(clipSceneController, structuredLogger),
+                MidiTool.specification(bitwigApiFacade, structuredLogger),
+                ClipWriterTool.specification(bitwigApiFacade, structuredLogger),
+                ClipWriterTool.writeNoteSpecification(bitwigApiFacade, structuredLogger),
+                ClipWriterTool.writeNotesSpecification(bitwigApiFacade, structuredLogger),
+                ClipWriterTool.clearClipSpecification(bitwigApiFacade, structuredLogger),
+                DeviceInsertTool.insertBitwigDeviceSpecification(bitwigApiFacade, structuredLogger),
+                ListBitwigDevicesTool.specification(structuredLogger),
+                TrackManagementTool.createInstrumentTrackSpecification(bitwigApiFacade, structuredLogger),
+                TrackManagementTool.createAudioTrackSpecification(bitwigApiFacade, structuredLogger),
+                TrackManagementTool.createEffectTrackSpecification(bitwigApiFacade, structuredLogger),
+                TrackManagementTool.deleteTrackSpecification(bitwigApiFacade, structuredLogger),
+                TrackPropertiesTool.setTrackPropertiesSpecification(bitwigApiFacade, structuredLogger),
+                TrackPropertiesTool.setTrackSendSpecification(bitwigApiFacade, structuredLogger),
+                BatchOperationsTool.specification(bitwigApiFacade, structuredLogger),
+                GetDevicePageNamesTool.specification(bitwigApiFacade, structuredLogger),
+                GetDevicePageParametersTool.specification(bitwigApiFacade, structuredLogger)
+                // GetDeviceKnowledgeTool.specification(structuredLogger) // DISABLED - too much context for small LLMs
+                // VstScannerTool.scanPluginsSpecification(bitwigApiFacade.getVstPluginScanner(), structuredLogger) // TEMPORARILY DISABLED
             )
             .build();
 
Index: src/main/java/io/github/fabb/wigai/mcp/tool/ListDevicesOnTrackTool.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/io/github/fabb/wigai/mcp/tool/ListDevicesOnTrackTool.java b/src/main/java/io/github/fabb/wigai/mcp/tool/ListDevicesOnTrackTool.java
--- a/src/main/java/io/github/fabb/wigai/mcp/tool/ListDevicesOnTrackTool.java	(revision 3257236b82bd84c916ebff2f184e8f162f39a6d2)
+++ b/src/main/java/io/github/fabb/wigai/mcp/tool/ListDevicesOnTrackTool.java	(date 1761587997375)
@@ -128,7 +128,7 @@
         int paramCount = 0;
         if (trackIndex != null) paramCount++;
         if (trackName != null) paramCount++;
-        if (getSelected != null) paramCount++;
+        if (getSelected != null && getSelected) paramCount++;  // Only count if explicitly true
 
         if (paramCount > 1) {
             throw new IllegalArgumentException(

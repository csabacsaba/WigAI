# Story 8.2: Implement `get_device_details` Tool

**Epic:** [Epic 8: Device Information Retrieval](../epic-8.md)

**User Story:**

*   As an AI agent, I want to get detailed information for a specific device (identified by its track context + device index/name, or as the currently selected device in the project), including its full context, key states, its 8 remote controls (for the currently selected page, detailing existence, name, normalized value, raw value, display value), and its 8 remote control pages (listing all available pages and indicating which is selected), so I can deeply analyze or prepare to control that device via its main remote interface.

**Acceptance Criteria:**

*   An MCP tool named `get_device_details` is implemented.
*   The tool is registered in the MCP server and discoverable via capabilities/status; verified per [docs/testing/mcp-endpoints-verification.md](../testing/mcp-endpoints-verification.md).
*   **Request Parameters:**
    *   `track_index` (integer, optional): 0-based index of the track containing the device.
    *   `track_name` (string, optional): Name of the track containing the device.
    *   `device_index` (integer, optional): 0-based index of the device on its track.
    *   `device_name` (string, optional): Name of the device.
    *   `get_for_selected_device` (boolean, optional): If `true` (and no other identifiers are provided), retrieves details for the currently selected device. Defaults to `true` if no other specifiers are given.
*   **Response Body:** A single device object containing:
    *   `track_index` (integer), `track_name` (string).
    *   `index` (integer), `name` (string), `type` (string).
    *   `is_bypassed` (boolean), `is_expanded` (boolean), `is_window_open` (boolean), `is_selected` (boolean).
    *   `remote_controls` (array of 8 remote control objects, **representing the slots of the currently selected remote control page**):
        *   `index` (integer, 0-7), `exists` (boolean).
        *   `name` (string, nullable), `value` (float, nullable), `raw_value` (float, nullable), `display_value` (string, nullable).
    *   `remote_control_pages` (array of 8 page objects, listing all available pages):
        *   `index` (integer, 0-7), `exists` (boolean).
        *   `name` (string, nullable), `is_selected` (boolean, nullable). <!-- Only one page will have is_selected: true -->
*   The tool correctly identifies the target `Device` based on the request parameters (track context + device context, or selected device).
*   All device-level fields (`track_index`, `track_name`, `index`, `name`, `type`, `is_bypassed`, `is_expanded`, `is_window_open`, `is_selected`) are correctly retrieved.
*   The `remote_controls` array is correctly populated by accessing the device's primary `RemoteControlBank` (e.g., via `device.remoteControls()`), which reflects the controls of the currently selected page. Each `RemoteControl` object in this bank provides:
    *   `exists` is true if `RemoteControl.name().get()` is not empty/null (or a similar reliable check for a mapped parameter).
    *   `name` is from `RemoteControl.name().get()`.
    *   `value` is from `RemoteControl.value().get()` (normalized 0-1).
    *   `raw_value` is from `RemoteControl.value().getRaw()`.
    *   `display_value` is from `RemoteControl.displayedValue().get()`.
*   The `remote_control_pages` array is correctly populated by accessing the device's `RemoteControlPageBank` (e.g., `device.remoteControls().pageBank()`). For each `RemoteControlPage` (up to 8):
    *   `exists` is true if `RemoteControlPage.name().get()` is not empty/null.
    *   `name` is from `RemoteControlPage.name().get()`.
    *   `is_selected` is from `RemoteControlPage.isSelected().get()`. Only one page should report `is_selected: true`.
*   The tool handles cases where a device or track is not found by returning an appropriate error response.
*   The tool handles devices with fewer than 8 active remote controls on the current page or fewer than 8 pages gracefully (fields are nullable or `exists` is false).
*   The `api-reference.md` is updated with the `get_device_details` tool specification.
*   Unit tests are written for the `GetDeviceDetailsTool.java` logic.
*   Manual testing confirms accuracy.

### Implementation Rules and Clarifications

- Parameter resolution and precedence
  - Modes:
    - Selected-device mode: if `get_for_selected_device` is `true` OR no identifiers are provided, target the globally selected device.
    - Target-by-identifiers mode: if any of `track_index`, `track_name`, `device_index`, or `device_name` is provided, the tool targets that specific device.
  - Constraints:
    - Providing `get_for_selected_device: true` together with any identifier parameter is invalid → `INVALID_PARAMETER`.
    - In target-by-identifiers mode:
      - Exactly one of `track_index` OR `track_name` must be provided; not both → `INVALID_PARAMETER`.
      - Exactly one of `device_index` OR `device_name` must be provided; not both → `INVALID_PARAMETER`.
      - `track_name` and `device_name` are case-sensitive exact matches.
    - If `get_for_selected_device` is `false` (or omitted) and no identifiers are provided → `INVALID_PARAMETER`.
    - Index validation: negative or out-of-bounds `track_index` / `device_index` → `INVALID_RANGE`.
  - Not-found handling:
    - Track not found → `TRACK_NOT_FOUND`.
    - Device not found on track → `DEVICE_NOT_FOUND`.
    - No selected device when required → `DEVICE_NOT_SELECTED`.

- Device fields availability
  - `type`: One of `"Instrument" | "AudioFX" | "NoteFX" | "Unknown"` (same semantics as device lists).
  - UI fields `is_expanded`, `is_window_open` may not be exposed by the Controller API; return `null` when unavailable.
  - `is_selected` should be derived by comparing to the global `CursorDevice` (index and track context preferred).

- Remote controls (current page) and pages
  - Remote controls: use `device.remoteControls()` as the primary bank for the currently selected page; iterate indexes `0..7`.
    - `exists`: `true` if `RemoteControl.name().get()` is non-empty; otherwise `false` (defined heuristic).
    - `name`: from `RemoteControl.name().get()`.
    - `value`: normalized `0.0..1.0` from `RemoteControl.value().get()`.
    - `raw_value`: if the API exposes a raw value accessor, populate it; otherwise set `null` (do not synthesize).
    - `display_value`: from `RemoteControl.displayedValue().get()`.
  - Remote control pages: use `device.remoteControls().pageBank()`, iterate `0..7`.
    - `exists`: `true` if `RemoteControlPage.name().get()` is non-empty.
    - `name`: from `RemoteControlPage.name().get()`.
    - `is_selected`: from `RemoteControlPage.isSelected().get()`; exactly one page should be `true`.
  - If the device exposes fewer than 8 controls/pages, fill remaining slots with `exists: false` and other nullable fields as `null`.

- Response envelope and errors
  - Use the standard MCP envelope: `{ "status": "success" | "error", "data": { ... } | null, "message": "..."? }`, consistent with the existing API reference.
  - Error codes: `INVALID_PARAMETER`, `INVALID_RANGE`, `TRACK_NOT_FOUND`, `DEVICE_NOT_FOUND`, `DEVICE_NOT_SELECTED`, `BITWIG_API_ERROR`.

- Documentation
  - Add exact request/response schema and examples to `docs/api-reference.md` under a new "Device Information Commands" section for `get_device_details`, including an example where `raw_value` is `null`.

- Testing scope (unit + manual)
  - Unit tests should cover:
    - Parameter validation (mutual exclusivity, defaults, invalid combos).
    - Selected-device path vs. identifier-based path.
    - Not-found cases for track/device and no selected device.
    - Devices with sparse controls and pages (exists=false, null fields).
    - Correct page selection (controls reflect selected page; pages mark selection).
  - Manual checklist:
    - Project with: at least one instrument with multiple remote control pages, a device with <8 mapped controls, and at least one device bypassed.
    - Verify values match Bitwig UI for the selected page; toggle selected page and re-verify.
    - Validate behavior when no device is selected.

**Tasks:**

1.  Create `GetDeviceDetailsTool.java` implementing `MCPTool`.
2.  Implement logic to resolve the target `Device` object:
    *   If `get_for_selected_device` is true (or default), use `CursorDevice`.
    *   Else, find track by `track_index`/`track_name`, then find device on track by `device_index`/`device_name` from its `DeviceChain`.
3.  If device is found, retrieve basic device properties.
4.  Access the primary `RemoteControlBank` for the device (e.g., `device.remoteControls()`). This bank represents the controls for the **currently selected page**.
5.  Iterate 0-7 for the `remote_controls` array:
    *   Get `RemoteControl` object using `bank.getParameter(i)`.
    *   Populate `exists`, `name`, `value`, `raw_value`, `display_value`.
6.  Access the `RemoteControlPageBank` for the device (e.g., `device.remoteControls().pageBank()`).
7.  Iterate 0-7 for the `remote_control_pages` array:
    *   Get `RemoteControlPage` object using `pageBank.getItemAt(i)`.
    *   Populate `exists`, `name`, `is_selected`.
8.  Construct the JSON response.
9.  Add error handling (device/track not found, API issues).
10. Update `docs/api-reference.md`.
11. Write JUnit tests.
12. Perform manual integration testing.

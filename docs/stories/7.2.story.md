# Story 7.2: Implement `get_clips_in_scene` Tool

**Epic:** [Epic 7: Scene and Clip Information Retrieval](../epic-7.md)

**User Story:**

*   As an AI agent, I want to get detailed information for all clips within a specific scene (by index or name), including their track context, content properties (name, color, length, loop status), and playback states, so I can analyze or prepare a scene for launching.

**Acceptance Criteria:**

*   An MCP tool named `get_clips_in_scene` is implemented.
*   **Request Parameters:**
    *   `scene_index` (integer, optional): 0-based index of the scene. Must be &#62;= 0.
    *   `scene_name` (string, optional): Name of the scene.
    *   At least one of `scene_index` or `scene_name` must be provided.
    *   If both are provided, `scene_name` takes precedence.
    *   Invalid `scene_index` (negative or out of range) results in an invalid-parameter error.
    *   Scene name comparison is case-insensitive and trimmed.
*   **Response Body:** An array of clip slot objects for the specified scene. Each object contains:
    *   `track_index` (integer): 0-based index of the track this slot belongs to.
    *   `track_name` (string): Name of the track this slot belongs to.
    *   `has_content` (boolean): True if a clip exists in this slot.
    *   `clip_name` (string, nullable): Name of the clip if `has_content` is true; otherwise null.
    *   `clip_color` (string, nullable): Hex color in “#RRGGBB” if `has_content` is true; otherwise null.
    *   `length` (string, nullable): Length as “bars.beats.sixteenths” (e.g., "4.0.0") if `has_content` is true; otherwise null.
    *   `is_looping` (boolean, nullable): True if the clip is set to loop when `has_content` is true; otherwise null.
    *   `is_playing` (boolean): True if the clip in this slot is currently playing.
    *   `is_recording` (boolean): True if the clip in this slot is currently recording.
    *   `is_playback_queued` (boolean): True if playback is queued for the clip in this slot.
    *   `is_recording_queued` (boolean): True if recording is queued for the clip in this slot.
    *   `is_stop_queued` (boolean): True if a stop is queued for the clip in this slot.
*   The tool includes an entry for every track’s slot at the target scene index:
    *   If the slot has no clip: `has_content=false`; `clip_name`, `clip_color`, `length`, `is_looping` are null; all playback/queue booleans are false.
*   The `get_clips_in_scene` tool correctly identifies the target scene based on `scene_index` or `scene_name`.
*   Scene name disambiguation: if multiple scenes share the same name, the first match by index is used.
*   The tool iterates through all tracks (`TrackBank`) and for each track, accesses its `ClipLauncherSlotBank` at the specified scene's index to retrieve clip details.
*   The tool correctly populates all specified fields for each clip slot object.
*   Values reflect a consistent snapshot at query time (single API tick) following existing facade patterns.
*   Error responses follow the standardized WigAI MCP error model:
    *   Scene not found → code `SCENE_NOT_FOUND`, message: "Scene not found: &#60;name or index&#62;".
    *   Invalid parameter → code `INVALID_PARAMETER`, message describing the issue.
*   The `api-reference.md` is updated with the `get_clips_in_scene` tool specification (parameters, validation rules, response schema with nullability, and error cases).
*   Unit tests are written for the `GetClipsInSceneTool.java` logic.
*   Manual testing confirms accuracy against various Bitwig project configurations.

**Design Notes:**

*   Scene resolution order: prefer `scene_name` when both are provided; otherwise use `scene_index`.
*   Name matching: case-insensitive, trimmed; duplicates select the first scene by index.
*   Output inclusion policy: always include all tracks’ slots for the target scene.
*   Color format: hex `#RRGGBB`.
*   Length format: bars.beats.sixteenths, e.g., `4.0.0`.
*   Snapshot semantics: read values in one consistent tick; avoid mixing observed states across ticks.
*   Playback flags: values should directly mirror Bitwig API flags at the time of read; no precedence collapsing required.

**Tasks:**

1.  Create `GetClipsInSceneTool.java` implementing the `MCPTool` interface.
2.  Implement logic to identify the target scene by `scene_index` or `scene_name` (with precedence and matching rules).
3.  If scene is found, iterate through all tracks in the project (`TrackBank`).
4.  For each track, get the `ClipLauncherSlot` at the target scene's index.
5.  From the slot, extract all required clip information: `track_index`, `track_name`, `has_content`, `clip_name`, `clip_color`, `length`, `is_looping`, and all playback/queue states.
6.  Construct the JSON response array as specified (include all tracks, empty-slot fields set as described).
7.  Implement robust error handling (invalid parameter, scene not found) using the standard MCP error model.
8.  Update `docs/api-reference.md` with the `get_clips_in_scene` tool details.
9.  Write JUnit tests for `GetClipsInSceneTool.java` covering index/name paths, not-found, empty vs populated slots, state flags, and case/whitespace handling.
10. Perform manual integration testing across projects with empty scenes, duplicates, and mixed playback/recording states.